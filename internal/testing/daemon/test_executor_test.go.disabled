package daemon

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/nodelistdb/internal/testing/daemon/mocks"
	"github.com/nodelistdb/internal/testing/daemon/testutil"
	"github.com/nodelistdb/internal/testing/models"
	"github.com/nodelistdb/internal/testing/protocols"
	"github.com/nodelistdb/internal/testing/services"
)

func TestTestExecutor_SingleHostname_Success(t *testing.T) {
	// Setup
	node := testutil.NewNodeBuilder().
		WithAddress(2, 5020, 1).
		WithHostnames("test.fidonet.org").
		WithProtocols("IBN").
		Build()

	mockDNS := &mocks.MockDNSResolver{
		ResolveFunc: func(ctx context.Context, hostname string) *services.DNSResult {
			return &services.DNSResult{
				Hostname:      hostname,
				IPv4Addresses: []string{"192.0.2.1"},
				IPv6Addresses: []string{"2001:db8::1"},
				Error:         nil,
			}
		},
	}

	mockGeo := &mocks.MockGeolocation{}
	mockStorage := &mocks.MockStorage{}

	daemon := &Daemon{
		dnsResolver: mockDNS,
		geolocator:  mockGeo,
		storage:     mockStorage,
		config:      testutil.NewConfigBuilder().Build(),
	}

	// Mock the testBinkP method
	daemon.binkpTester = &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			return &protocols.BinkPTestResult{
				BaseTestResult: protocols.BaseTestResult{
					Success:    true,
					ResponseMs: 100,
				},
				SystemName:   "Remote System",
				AddressValid: true,
			}
		},
	}

	executor := NewTestExecutor(daemon)

	// Execute
	result := executor.TestNode(context.Background(), node)

	// Verify
	if result == nil {
		t.Fatal("Expected non-nil result")
	}

	if result.Zone != 2 || result.Net != 5020 || result.Node != 1 {
		t.Errorf("Wrong node address in result: %d:%d/%d", result.Zone, result.Net, result.Node)
	}

	if len(result.ResolvedIPv4) != 1 || result.ResolvedIPv4[0] != "192.0.2.1" {
		t.Errorf("Wrong IPv4 resolution: %v", result.ResolvedIPv4)
	}

	if len(result.ResolvedIPv6) != 1 || result.ResolvedIPv6[0] != "2001:db8::1" {
		t.Errorf("Wrong IPv6 resolution: %v", result.ResolvedIPv6)
	}

	// Verify NO storage calls from executor (storage handled by daemon)
	if len(mockStorage.GetStoreCalls()) > 0 {
		t.Errorf("TestExecutor should not store results, found %d store calls", len(mockStorage.GetStoreCalls()))
	}
}

func TestTestExecutor_SingleHostname_DNSFailure(t *testing.T) {
	// Setup
	node := testutil.NewNodeBuilder().
		WithAddress(2, 5020, 1).
		WithHostnames("nonexistent.example.com").
		Build()

	mockDNS := &mocks.MockDNSResolver{
		ResolveFunc: func(ctx context.Context, hostname string) *services.DNSResult {
			return &services.DNSResult{
				Hostname: hostname,
				Error:    errors.New("NXDOMAIN"),
			}
		},
	}

	daemon := &Daemon{
		dnsResolver: mockDNS,
		storage:     &mocks.MockStorage{},
		config:      testutil.NewConfigBuilder().Build(),
	}

	executor := NewTestExecutor(daemon)

	// Execute
	result := executor.TestNode(context.Background(), node)

	// Verify
	if result == nil {
		t.Fatal("Expected non-nil result")
	}

	if result.DNSError != "NXDOMAIN" {
		t.Errorf("Expected DNS error NXDOMAIN, got: %s", result.DNSError)
	}

	if result.IsOperational {
		t.Error("Node should not be operational with DNS failure")
	}

	if len(result.ResolvedIPv4) > 0 || len(result.ResolvedIPv6) > 0 {
		t.Error("Should have no resolved IPs on DNS failure")
	}
}

func TestTestExecutor_MultipleHostnames_AllSuccess(t *testing.T) {
	// Setup
	node := testutil.NewNodeBuilder().
		WithAddress(1, 1, 1).
		WithHostnames("primary.example.com", "backup.example.com").
		WithProtocols("IBN", "IFC").
		Build()

	mockDNS := &mocks.MockDNSResolver{
		ResolveFunc: func(ctx context.Context, hostname string) *services.DNSResult {
			if hostname == "primary.example.com" {
				return &services.DNSResult{
					Hostname:      hostname,
					IPv4Addresses: []string{"192.0.2.1"},
					Error:         nil,
				}
			}
			return &services.DNSResult{
				Hostname:      hostname,
				IPv4Addresses: []string{"192.0.2.2"},
				Error:         nil,
			}
		},
	}

	daemon := &Daemon{
		dnsResolver: mockDNS,
		geolocator:  &mocks.MockGeolocation{},
		storage:     &mocks.MockStorage{},
		config:      testutil.NewConfigBuilder().Build(),
	}

	executor := NewTestExecutor(daemon)

	// Execute
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	result := executor.TestNode(ctx, node)

	// Verify
	if result == nil {
		t.Fatal("Expected non-nil result for multi-hostname node")
	}

	// Should be aggregated result
	if !result.IsAggregated {
		t.Error("Result should be aggregated for multi-hostname node")
	}

	if result.TotalHostnames != 2 {
		t.Errorf("Expected 2 total hostnames, got %d", result.TotalHostnames)
	}
}

func TestTestExecutor_MultipleHostnames_PartialSuccess(t *testing.T) {
	// Setup
	node := testutil.NewNodeBuilder().
		WithAddress(1, 1, 1).
		WithHostnames("working.example.com", "broken.example.com").
		WithProtocols("IBN").
		Build()

	mockDNS := &mocks.MockDNSResolver{
		ResolveFunc: func(ctx context.Context, hostname string) *services.DNSResult {
			if hostname == "working.example.com" {
				return &services.DNSResult{
					Hostname:      hostname,
					IPv4Addresses: []string{"192.0.2.1"},
					Error:         nil,
				}
			}
			return &services.DNSResult{
				Hostname: hostname,
				Error:    errors.New("DNS timeout"),
			}
		},
	}

	daemon := &Daemon{
		dnsResolver: mockDNS,
		geolocator:  &mocks.MockGeolocation{},
		storage:     &mocks.MockStorage{},
		config:      testutil.NewConfigBuilder().Build(),
	}

	executor := NewTestExecutor(daemon)

	// Execute
	result := executor.TestNode(context.Background(), node)

	// Verify
	if result == nil {
		t.Fatal("Expected non-nil result")
	}

	// At least one hostname worked
	if len(result.ResolvedIPv4) == 0 {
		t.Error("Should have IPs from working hostname")
	}
}

func TestTestExecutor_ContextCancellation_ReturnsNonNil(t *testing.T) {
	// Setup
	node := testutil.NewNodeBuilder().
		WithAddress(1, 1, 1).
		WithHostnames("host1.example.com", "host2.example.com", "host3.example.com").
		Build()

	slowDNS := &mocks.MockDNSResolver{
		ResolveFunc: func(ctx context.Context, hostname string) *services.DNSResult {
			// Simulate slow DNS that respects context
			select {
			case <-ctx.Done():
				return &services.DNSResult{
					Hostname: hostname,
					Error:    ctx.Err(),
				}
			case <-time.After(100 * time.Millisecond):
				return &services.DNSResult{
					Hostname:      hostname,
					IPv4Addresses: []string{"192.0.2.1"},
				}
			}
		},
	}

	daemon := &Daemon{
		dnsResolver: slowDNS,
		storage:     &mocks.MockStorage{},
		config:      testutil.NewConfigBuilder().Build(),
	}

	executor := NewTestExecutor(daemon)

	// Execute with immediate cancellation
	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel immediately

	result := executor.TestNode(ctx, node)

	// Verify - MUST return non-nil to prevent scheduler crash
	if result == nil {
		t.Fatal("TestExecutor must return non-nil result even on context cancellation")
	}
}

func TestTestExecutor_NoHostnames_UsesSystemName(t *testing.T) {
	// Setup
	node := testutil.NewNodeBuilder().
		WithAddress(3, 100, 1).
		WithNoHostnames().
		WithSystemName("bbs.local.net").
		Build()

	mockDNS := &mocks.MockDNSResolver{
		ResolveFunc: func(ctx context.Context, hostname string) *services.DNSResult {
			if hostname == "bbs.local.net" {
				return &services.DNSResult{
					Hostname:      hostname,
					IPv4Addresses: []string{"10.0.0.1"},
					Error:         nil,
				}
			}
			return &services.DNSResult{
				Hostname: hostname,
				Error:    errors.New("Unknown host"),
			}
		},
	}

	daemon := &Daemon{
		dnsResolver: mockDNS,
		storage:     &mocks.MockStorage{},
		config:      testutil.NewConfigBuilder().Build(),
	}

	executor := NewTestExecutor(daemon)

	// Execute
	result := executor.TestNode(context.Background(), node)

	// Verify
	if result == nil {
		t.Fatal("Expected non-nil result")
	}

	// Should have used system name as hostname
	if len(mockDNS.ResolveCalls) == 0 {
		t.Error("Should have attempted DNS resolution")
	}

	if mockDNS.ResolveCalls[0] != "bbs.local.net" {
		t.Errorf("Should have resolved system name, got: %s", mockDNS.ResolveCalls[0])
	}
}

func TestTestExecutor_DetermineOperationalStatus(t *testing.T) {
	executor := &TestExecutor{}

	tests := []struct {
		name          string
		result        *models.TestResult
		expectedOp    bool
	}{
		{
			name: "BinkP success makes operational",
			result: &models.TestResult{
				BinkPResult: &models.ProtocolTestResult{
					Tested:  true,
					Success: true,
				},
			},
			expectedOp: true,
		},
		{
			name: "IFCico success makes operational",
			result: &models.TestResult{
				IfcicoResult: &models.ProtocolTestResult{
					Tested:  true,
					Success: true,
				},
			},
			expectedOp: true,
		},
		{
			name: "All protocols failed not operational",
			result: &models.TestResult{
				BinkPResult: &models.ProtocolTestResult{
					Tested:  true,
					Success: false,
				},
				IfcicoResult: &models.ProtocolTestResult{
					Tested:  true,
					Success: false,
				},
			},
			expectedOp: false,
		},
		{
			name: "No protocols tested not operational",
			result: &models.TestResult{
				ResolvedIPv4: []string{"192.0.2.1"},
			},
			expectedOp: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			operational := executor.determineOperationalStatus(tt.result)
			if operational != tt.expectedOp {
				t.Errorf("Expected operational=%v, got %v", tt.expectedOp, operational)
			}
		})
	}
}

func TestTestExecutor_DelegationToProtocolMethods(t *testing.T) {
	// This test verifies that TestExecutor delegates to daemon's protocol methods
	// instead of implementing its own protocol testing

	node := testutil.NewNodeBuilder().
		WithProtocols("IBN").
		Build()

	mockDNS := &mocks.MockDNSResolver{}

	// Track if testBinkP was called
	testBinkPCalled := false

	daemon := &Daemon{
		dnsResolver: mockDNS,
		storage:     &mocks.MockStorage{},
		config:      testutil.NewConfigBuilder().Build(),
		binkpTester: &mocks.MockProtocolTester{},
	}

	// Override testBinkP to track calls
	oldTestBinkP := daemon.testBinkP
	daemon.testBinkP = func(ctx context.Context, n *models.Node, r *models.TestResult) {
		testBinkPCalled = true
		// Set a result to show it was called
		r.BinkPResult = &models.ProtocolTestResult{
			Tested:  true,
			Success: true,
		}
	}
	defer func() { daemon.testBinkP = oldTestBinkP }()

	executor := NewTestExecutor(daemon)

	// Execute
	result := executor.TestNode(context.Background(), node)

	// Verify delegation occurred
	if !testBinkPCalled {
		t.Error("TestExecutor should delegate to daemon.testBinkP")
	}

	if result.BinkPResult == nil || !result.BinkPResult.Success {
		t.Error("BinkP result should reflect delegation to daemon method")
	}
}