package daemon

import (
	"testing"
	"time"

	"github.com/nodelistdb/internal/testing/models"
	"github.com/nodelistdb/internal/testing/daemon/testutil"
)

func TestAggregator_EmptyResults_ReturnsValid(t *testing.T) {
	aggregator := &TestAggregator{}
	result := aggregator.AggregateResults([]*models.SingleHostTestResult{})

	if result == nil {
		t.Fatal("Expected non-nil result for empty input")
	}

	if result.OperationalCount != 0 {
		t.Errorf("Expected operational count to be 0, got %d", result.OperationalCount)
	}

	if result.TestedCount != 0 {
		t.Errorf("Expected tested count to be 0, got %d", result.TestedCount)
	}
}

func TestAggregator_SingleResult_NoAggregation(t *testing.T) {
	aggregator := &TestAggregator{}

	singleResult := testutil.NewTestResultBuilder().
		WithHostname("bbs.example.com").
		WithIPv4("192.168.1.1").
		WithDNSResolved(true).
		WithProtocolResult("IBN", true, nil, 100*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{singleResult})

	if result == nil {
		t.Fatal("Expected non-nil result")
	}

	if result.TestedHostname != "bbs.example.com" {
		t.Errorf("Expected tested hostname to be bbs.example.com, got %s", result.TestedHostname)
	}

	if result.OperationalCount != 1 {
		t.Errorf("Expected operational count to be 1, got %d", result.OperationalCount)
	}

	if result.TestedCount != 1 {
		t.Errorf("Expected tested count to be 1, got %d", result.TestedCount)
	}

	if !result.IsOperational {
		t.Error("Expected node to be operational")
	}
}

func TestAggregator_MultipleResults_AggregatesCorrectly(t *testing.T) {
	aggregator := &TestAggregator{}

	result1 := testutil.NewTestResultBuilder().
		WithHostname("primary.example.com").
		WithIPv4("192.168.1.1").
		WithDNSResolved(true).
		WithProtocolResult("IBN", true, nil, 100*time.Millisecond).
		Build()

	result2 := testutil.NewTestResultBuilder().
		WithHostname("backup.example.com").
		WithIPv4("192.168.1.2").
		WithDNSResolved(true).
		WithProtocolResult("IBN", false, nil, 200*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{result1, result2})

	if result == nil {
		t.Fatal("Expected non-nil result")
	}

	if result.TestedCount != 2 {
		t.Errorf("Expected tested count to be 2, got %d", result.TestedCount)
	}

	if result.OperationalCount != 1 {
		t.Errorf("Expected operational count to be 1 (only primary works), got %d", result.OperationalCount)
	}

	if result.TestedHostname != "primary.example.com" {
		t.Errorf("Expected tested hostname to be primary.example.com (operational), got %s", result.TestedHostname)
	}

	if !result.IsOperational {
		t.Error("Expected node to be operational (at least one hostname works)")
	}
}

func TestAggregator_OperationalCount_OnlyCountsProtocolSuccess(t *testing.T) {
	aggregator := &TestAggregator{}

	// DNS success but protocol fail - NOT operational
	result1 := testutil.NewTestResultBuilder().
		WithHostname("dns-ok.example.com").
		WithIPv4("192.168.1.1").
		WithDNSResolved(true).
		WithProtocolResult("IBN", false, nil, 100*time.Millisecond).
		Build()

	// DNS fail - NOT operational
	result2 := testutil.NewTestResultBuilder().
		WithHostname("dns-fail.example.com").
		WithDNSResolved(false).
		Build()

	// Protocol success - IS operational
	result3 := testutil.NewTestResultBuilder().
		WithHostname("all-ok.example.com").
		WithIPv4("192.168.1.3").
		WithDNSResolved(true).
		WithProtocolResult("IBN", true, nil, 50*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{result1, result2, result3})

	if result.OperationalCount != 1 {
		t.Errorf("Expected operational count to be 1 (only all-ok.example.com), got %d", result.OperationalCount)
	}

	if result.TestedCount != 3 {
		t.Errorf("Expected tested count to be 3, got %d", result.TestedCount)
	}
}

func TestAggregator_TestedHostname_PrefersOperational(t *testing.T) {
	aggregator := &TestAggregator{}

	// First hostname - fails
	result1 := testutil.NewTestResultBuilder().
		WithHostname("primary.example.com").
		WithIPv4("192.168.1.1").
		WithDNSResolved(true).
		WithProtocolResult("IBN", false, nil, 100*time.Millisecond).
		Build()

	// Second hostname - succeeds
	result2 := testutil.NewTestResultBuilder().
		WithHostname("backup.example.com").
		WithIPv4("192.168.1.2").
		WithDNSResolved(true).
		WithProtocolResult("IBN", true, nil, 200*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{result1, result2})

	// Should prefer the operational hostname even if it's not first
	if result.TestedHostname != "backup.example.com" {
		t.Errorf("Expected tested hostname to be backup.example.com (operational), got %s", result.TestedHostname)
	}
}

func TestAggregator_DNSSuccess_ProtocolFail_HasConnectivityIssues(t *testing.T) {
	aggregator := &TestAggregator{}

	result1 := testutil.NewTestResultBuilder().
		WithHostname("bbs.example.com").
		WithIPv4("192.168.1.1").
		WithDNSResolved(true).
		WithProtocolResult("IBN", false, nil, 100*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{result1})

	if result.HasDNSIssues {
		t.Error("Should not have DNS issues when DNS resolved successfully")
	}

	if !result.HasConnectivityIssues {
		t.Error("Should have connectivity issues when DNS succeeds but protocol fails")
	}
}

func TestAggregator_MixedIPv4IPv6_AggregatesAll(t *testing.T) {
	aggregator := &TestAggregator{}

	result1 := testutil.NewTestResultBuilder().
		WithHostname("dual-stack.example.com").
		WithIPv4("192.168.1.1").
		WithIPv6("2001:db8::1").
		WithDNSResolved(true).
		WithProtocolResult("IBN", true, nil, 100*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{result1})

	if len(result.IPv4Addresses) != 1 || result.IPv4Addresses[0] != "192.168.1.1" {
		t.Errorf("Expected IPv4 address to be aggregated, got %v", result.IPv4Addresses)
	}

	if len(result.IPv6Addresses) != 1 || result.IPv6Addresses[0] != "2001:db8::1" {
		t.Errorf("Expected IPv6 address to be aggregated, got %v", result.IPv6Addresses)
	}
}

func TestAggregator_ProtocolResults_TakesBestFromAny(t *testing.T) {
	aggregator := &TestAggregator{}

	// First hostname - IBN fails, IFC succeeds
	result1 := testutil.NewTestResultBuilder().
		WithHostname("host1.example.com").
		WithIPv4("192.168.1.1").
		WithDNSResolved(true).
		WithProtocolResult("IBN", false, nil, 100*time.Millisecond).
		WithProtocolResult("IFC", true, nil, 150*time.Millisecond).
		Build()

	// Second hostname - IBN succeeds, IFC not tested
	result2 := testutil.NewTestResultBuilder().
		WithHostname("host2.example.com").
		WithIPv4("192.168.1.2").
		WithDNSResolved(true).
		WithProtocolResult("IBN", true, nil, 200*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{result1, result2})

	// Should take the best result for each protocol across all hostnames
	ibnResult := result.ProtocolResults["IBN"]
	if ibnResult == nil || !ibnResult.Success {
		t.Error("Expected IBN to be successful (from host2)")
	}

	ifcResult := result.ProtocolResults["IFC"]
	if ifcResult == nil || !ifcResult.Success {
		t.Error("Expected IFC to be successful (from host1)")
	}
}

func TestAggregator_AllHostnamesFail_NodeNotOperational(t *testing.T) {
	aggregator := &TestAggregator{}

	result1 := testutil.NewTestResultBuilder().
		WithHostname("host1.example.com").
		WithDNSResolved(false).
		Build()

	result2 := testutil.NewTestResultBuilder().
		WithHostname("host2.example.com").
		WithIPv4("192.168.1.2").
		WithDNSResolved(true).
		WithProtocolResult("IBN", false, nil, 200*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{result1, result2})

	if result.IsOperational {
		t.Error("Expected node to be not operational when all hostnames fail")
	}

	if result.OperationalCount != 0 {
		t.Errorf("Expected operational count to be 0, got %d", result.OperationalCount)
	}

	if result.TestedCount != 2 {
		t.Errorf("Expected tested count to be 2, got %d", result.TestedCount)
	}
}

func TestAggregator_GeolocationData_Aggregated(t *testing.T) {
	aggregator := &TestAggregator{}

	result1 := testutil.NewTestResultBuilder().
		WithHostname("us.example.com").
		WithIPv4("192.168.1.1").
		WithDNSResolved(true).
		WithGeolocation("United States", "US", "New York", "NYC", 40.7128, -74.0060, "AS123", "Example ISP").
		WithProtocolResult("IBN", true, nil, 100*time.Millisecond).
		Build()

	result2 := testutil.NewTestResultBuilder().
		WithHostname("eu.example.com").
		WithIPv4("192.168.1.2").
		WithDNSResolved(true).
		WithGeolocation("Germany", "DE", "Berlin", "BER", 52.5200, 13.4050, "AS456", "Another ISP").
		WithProtocolResult("IBN", false, nil, 200*time.Millisecond).
		Build()

	result := aggregator.AggregateResults([]*models.SingleHostTestResult{result1, result2})

	// Should use geolocation from the operational hostname
	if result.Country != "United States" {
		t.Errorf("Expected country to be United States, got %s", result.Country)
	}

	if result.CountryCode != "US" {
		t.Errorf("Expected country code to be US, got %s", result.CountryCode)
	}

	if result.City != "New York" {
		t.Errorf("Expected city to be New York, got %s", result.City)
	}
}