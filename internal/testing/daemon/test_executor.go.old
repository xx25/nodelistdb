package daemon

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/nodelistdb/internal/testing/logging"
	"github.com/nodelistdb/internal/testing/models"
)

// TestExecutor handles test orchestration and execution
type TestExecutor struct {
	daemon *Daemon
}

// NewTestExecutor creates a new test executor
func NewTestExecutor(d *Daemon) *TestExecutor {
	return &TestExecutor{daemon: d}
}

// TestNode tests a node based on whether it has single or multiple hostnames
func (te *TestExecutor) TestNode(ctx context.Context, node *models.Node) *models.TestResult {
	// Note: Scheduling logic should be handled by the daemon before calling this method

	// Check if node has multiple hostnames
	if len(node.InternetHostnames) > 1 {
		return te.testMultipleHostnameNode(ctx, node)
	}
	return te.testSingleHostnameNode(ctx, node)
}

// testSingleHostnameNode tests a node with a single hostname
func (te *TestExecutor) testSingleHostnameNode(ctx context.Context, node *models.Node) *models.TestResult {
	hostname := ""
	if len(node.InternetHostnames) > 0 {
		hostname = node.InternetHostnames[0]
	}

	// Perform testing with the single hostname (or empty string if no hostname)
	result := te.performTesting(ctx, node, hostname)

	// Store the result
	if result != nil {
		if err := te.daemon.storage.StoreTestResult(ctx, result); err != nil {
			logging.Error(fmt.Sprintf("Failed to store test result for %s: %v",
				node.Address(), err))
		}
	}

	return result
}

// testMultipleHostnameNode tests a node with multiple hostnames
func (te *TestExecutor) testMultipleHostnameNode(ctx context.Context, node *models.Node) *models.TestResult {
	nodeAddr := node.Address()
	logging.Info(fmt.Sprintf("Testing node %s with %d hostnames", nodeAddr, len(node.InternetHostnames)))

	var results []*models.TestResult

	// Test each hostname
	for i, hostname := range node.InternetHostnames {
		logging.Debug(fmt.Sprintf("Testing hostname %d/%d: %s", i+1, len(node.InternetHostnames), hostname))

		// Perform testing for this specific hostname
		result := te.performTesting(ctx, node, hostname)
		if result != nil {
			// Mark this as a partial result for a specific hostname
			result.TestedHostname = hostname
			result.HostnameIndex = int32(i)
			result.IsAggregated = false

			// Store the partial result
			if err := te.daemon.storage.StoreTestResult(ctx, result); err != nil {
				logging.Error(fmt.Sprintf("Failed to store partial test result for %s (hostname: %s): %v",
					nodeAddr, hostname, err))
			}

			results = append(results, result)
		}

		// Add a small delay between hostname tests to avoid overwhelming the node
		select {
		case <-ctx.Done():
			return nil
		case <-time.After(100 * time.Millisecond):
		}
	}

	// Create an aggregated result
	if len(results) > 0 {
		aggregated := NewTestAggregator().CreateAggregatedResult(node, results)

		// Store the aggregated result
		if err := te.daemon.storage.StoreTestResult(ctx, aggregated); err != nil {
			logging.Errorf("Failed to store aggregated test result for %s: %v", nodeAddr, err)
		}

		return aggregated
	}

	return nil
}

// performTesting performs the actual testing of a node
func (te *TestExecutor) performTesting(ctx context.Context, node *models.Node, hostname string) *models.TestResult {
	result := &models.TestResult{
		Zone:           node.Zone,
		Net:            node.Net,
		Node:           node.Node,
		NodelistDate:   node.NodelistDate,
		TestTime:       time.Now(),
		TestedHostname: hostname,
	}

	nodeAddr := models.FormatNodeAddress(node.Zone, node.Net, node.Node)

	// Set initial operational status
	result.IsOperational = false

	// DNS resolution if hostname is provided
	if hostname != "" {
		logging.Debug("Starting DNS resolution for %s", hostname)
		dnsResult := te.daemon.dnsResolver.Resolve(ctx, hostname)
		result.DNSResult = &dnsResult

		if !dnsResult.Success {
			result.DNSError = dnsResult.Error
			logging.Info("DNS resolution failed for %s (%s): %s", nodeAddr, hostname, dnsResult.Error)
			te.logConnectivitySummary(nodeAddr, node, result)
			return result
		}

		// Store resolved IPs
		result.ResolvedIPv4 = dnsResult.IPv4Addresses
		result.ResolvedIPv6 = dnsResult.IPv6Addresses

		// Geolocation (optional, don't fail if it doesn't work)
		if len(dnsResult.IPv4Addresses) > 0 || len(dnsResult.IPv6Addresses) > 0 {
			var ipForGeo string
			if len(dnsResult.IPv4Addresses) > 0 {
				ipForGeo = dnsResult.IPv4Addresses[0]
			} else if len(dnsResult.IPv6Addresses) > 0 {
				ipForGeo = dnsResult.IPv6Addresses[0]
			}

			if ipForGeo != "" {
				logging.Debug(fmt.Sprintf("Performing geolocation for %s", ipForGeo))
				geoResult := te.daemon.geolocator.Lookup(ctx, ipForGeo)
				if geoResult != nil {
					result.Country = geoResult.Country
					result.CountryCode = geoResult.CountryCode
					result.City = geoResult.City
					result.Region = geoResult.Region
					result.Latitude = geoResult.Latitude
					result.Longitude = geoResult.Longitude
					result.ISP = geoResult.ISP
					result.Org = geoResult.Org
					result.ASN = geoResult.ASN
				}
			}
		}
	} else {
		logging.Debug("No hostname available for %s, skipping DNS resolution", nodeAddr)
	}

	// Protocol tests (only if we have connectivity)
	if hostname != "" && result.DNSResult != nil && result.DNSResult.Success {
		// Binkp test
		if node.HasProtocol("IBN") && te.daemon.binkpTester != nil {
			logging.Debug("Testing Binkp for %s", nodeAddr)
			binkpResult := te.daemon.binkpTester.Test(ctx, node, hostname)
			result.BinkpResult = &binkpResult
			te.logProtocolResult(nodeAddr, "Binkp", &binkpResult)
		}

		// IFCico/EMSI test
		if node.HasProtocol("IFC") && te.daemon.ifcicoTester != nil {
			logging.Debug("Testing IFCico/EMSI for %s", nodeAddr)
			ifcicoResult := te.daemon.ifcicoTester.Test(ctx, node, hostname)
			result.IFCicoResult = &ifcicoResult
			te.logProtocolResult(nodeAddr, "IFCico/EMSI", &ifcicoResult)
		}

		// Telnet test
		if node.HasProtocol("ITN") && te.daemon.telnetTester != nil {
			logging.Debug("Testing Telnet for %s", nodeAddr)
			telnetResult := te.daemon.telnetTester.Test(ctx, node, hostname)
			result.TelnetResult = &telnetResult
			te.logProtocolResult(nodeAddr, "Telnet", &telnetResult)
		}

		// FTP test
		if node.HasProtocol("IFT") && te.daemon.ftpTester != nil {
			logging.Debug("Testing FTP for %s", nodeAddr)
			ftpResult := te.daemon.ftpTester.Test(ctx, node, hostname)
			result.FTPResult = &ftpResult
			te.logProtocolResult(nodeAddr, "FTP", &ftpResult)
		}

		// Vmodem test
		if node.HasProtocol("IVM") && te.daemon.vmodemTester != nil {
			logging.Debug(fmt.Sprintf("Testing Vmodem for %s", nodeAddr))
			vmodemResult := te.daemon.vmodemTester.Test(ctx, node, hostname)
			result.VModemResult = &vmodemResult
			te.logProtocolResult(nodeAddr, "Vmodem", &vmodemResult)
		}
	}

	// Determine overall operational status based on test results
	result.IsOperational = te.determineOperationalStatus(result)

	// Log connectivity summary
	te.logConnectivitySummary(nodeAddr, node, result)

	return result
}

// determineOperationalStatus determines if the node is operational based on test results
func (te *TestExecutor) determineOperationalStatus(result *models.TestResult) bool {
	// Check if any protocol test succeeded
	if result.BinkPResult != nil && result.BinkPResult.Tested && result.BinkPResult.Success {
		return true
	}

	if result.IfcicoResult != nil && result.IfcicoResult.Tested && result.IfcicoResult.Success {
		return true
	}

	if result.TelnetResult != nil && result.TelnetResult.Tested && result.TelnetResult.Success {
		return true
	}

	if result.FTPResult != nil && result.FTPResult.Tested && result.FTPResult.Success {
		return true
	}

	if result.VModemResult != nil && result.VModemResult.Tested && result.VModemResult.Success {
		return true
	}

	return false
}

// logProtocolResult logs the result of a protocol test
func (te *TestExecutor) logProtocolResult(nodeAddr, protocol string, result *models.ProtocolTestResult) {
	if result == nil || !result.Tested {
		return
	}

	if result.Success {
		if result.Details != nil && result.Details["version"] != nil {
			logging.Info(fmt.Sprintf("✓ %s %s: Success (Version: %v)", nodeAddr, protocol, result.Details["version"]))
		} else {
			logging.Info(fmt.Sprintf("✓ %s %s: Success", nodeAddr, protocol))
		}
	} else {
		if result.Error != "" {
			logging.Info(fmt.Sprintf("✗ %s %s: Failed (%s)", nodeAddr, protocol, result.Error))
		} else {
			logging.Info(fmt.Sprintf("✗ %s %s: Failed", nodeAddr, protocol))
		}
	}
}

// logConnectivitySummary logs a summary of connectivity test results
func (te *TestExecutor) logConnectivitySummary(nodeAddr string, node *models.Node, result *models.TestResult) {
	var summary []string

	// DNS status
	if result.DNSError == "" && (len(result.ResolvedIPv4) > 0 || len(result.ResolvedIPv6) > 0) {
		ipCount := len(result.ResolvedIPv4) + len(result.ResolvedIPv6)
		summary = append(summary, fmt.Sprintf("DNS:OK(%d IPs)", ipCount))

		// Add geolocation if available
		if result.Country != "" {
			summary = append(summary, fmt.Sprintf("Geo:%s", result.Country))
		}
	} else if result.DNSError != "" {
		summary = append(summary, "DNS:FAIL")
	} else if result.TestedHostname == "" {
		summary = append(summary, "DNS:N/A")
	}

	// Protocol statuses
	protocolResults := []struct {
		name   string
		has    bool
		result *models.ProtocolTestResult
	}{
		{"Binkp", node.HasBinkP(), result.BinkPResult},
		{"EMSI", node.HasIFCICO(), result.IfcicoResult},
		{"Telnet", node.HasTEL(), result.TelnetResult},
		{"FTP", node.HasProtocol("IFT"), result.FTPResult},
		{"Vmodem", node.HasProtocol("IVM"), result.VModemResult},
	}

	for _, pr := range protocolResults {
		if pr.has && pr.result != nil && pr.result.Tested {
			if pr.result.Success {
				summary = append(summary, fmt.Sprintf("%s:✓", pr.name))
			} else {
				summary = append(summary, fmt.Sprintf("%s:✗", pr.name))
			}
		}
	}

	// Overall status
	statusStr := "OFFLINE"
	if result.IsOperational {
		statusStr = "ONLINE"
	} else if result.DNSError != "" {
		statusStr = "DNS_FAIL"
	} else if result.BinkPResult != nil || result.IfcicoResult != nil || result.TelnetResult != nil ||
			result.FTPResult != nil || result.VModemResult != nil {
		statusStr = "CONN_FAIL"
	}

	logging.Info(fmt.Sprintf("Summary %s: [%s] %s", nodeAddr, statusStr, strings.Join(summary, " ")))
}