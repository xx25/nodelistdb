package daemon

import (
	"fmt"
	"testing"

	"github.com/nodelistdb/internal/testing/daemon/testutil"
	"github.com/nodelistdb/internal/testing/models"
)

func TestNodeFilter_SpecificAddress(t *testing.T) {
	filter := NewNodeFilter()

	nodes := []*models.Node{
		testutil.NewNodeBuilder().WithAddress(1, 1, 1).Build(),
		testutil.NewNodeBuilder().WithAddress(2, 5020, 100).Build(),
		testutil.NewNodeBuilder().WithAddress(2, 5020, 101).Build(),
		testutil.NewNodeBuilder().WithAddress(3, 100, 1).Build(),
	}

	// Test specific address filtering
	result := filter.FilterByTestLimit(nodes, "2:5020/100")

	if len(result) != 1 {
		t.Fatalf("Expected 1 node, got %d", len(result))
	}

	if result[0].Zone != 2 || result[0].Net != 5020 || result[0].Node != 100 {
		t.Errorf("Wrong node selected: %d:%d/%d", result[0].Zone, result[0].Net, result[0].Node)
	}
}

func TestNodeFilter_Percentage(t *testing.T) {
	filter := NewNodeFilter()

	// Create 100 nodes
	var nodes []*models.Node
	for i := 0; i < 100; i++ {
		nodes = append(nodes, testutil.NewNodeBuilder().
			WithAddress(1, 1, i+1).
			Build())
	}

	// Test 10% selection
	result := filter.FilterByTestLimit(nodes, "10%")

	if len(result) != 10 {
		t.Errorf("Expected 10 nodes (10%%), got %d", len(result))
	}

	// Test 0.5% should give at least 1
	result = filter.FilterByTestLimit(nodes, "0.5%")
	if len(result) != 1 {
		t.Errorf("Expected at least 1 node for 0.5%%, got %d", len(result))
	}
}

func TestNodeFilter_NumericLimit(t *testing.T) {
	filter := NewNodeFilter()

	var nodes []*models.Node
	for i := 0; i < 50; i++ {
		nodes = append(nodes, testutil.NewNodeBuilder().
			WithAddress(1, 1, i+1).
			Build())
	}

	tests := []struct {
		limit    string
		expected int
	}{
		{"5", 5},
		{"20", 20},
		{"100", 50}, // More than available
		{"0", 0},
		{"-1", 0},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf("limit_%s", tt.limit), func(t *testing.T) {
			result := filter.FilterByTestLimit(nodes, tt.limit)
			if len(result) != tt.expected {
				t.Errorf("Expected %d nodes, got %d", tt.expected, len(result))
			}
		})
	}
}

func TestNodeFilter_ZoneFiltering(t *testing.T) {
	filter := NewNodeFilter()

	nodes := []*models.Node{
		testutil.NewNodeBuilder().WithAddress(1, 1, 1).Build(),
		testutil.NewNodeBuilder().WithAddress(1, 2, 1).Build(),
		testutil.NewNodeBuilder().WithAddress(2, 1, 1).Build(),
		testutil.NewNodeBuilder().WithAddress(2, 2, 1).Build(),
		testutil.NewNodeBuilder().WithAddress(3, 1, 1).Build(),
	}

	result := filter.FilterByTestLimit(nodes, "zone:2")

	if len(result) != 2 {
		t.Fatalf("Expected 2 nodes in zone 2, got %d", len(result))
	}

	for _, node := range result {
		if node.Zone != 2 {
			t.Errorf("Got node from wrong zone: %d", node.Zone)
		}
	}
}

func TestNodeFilter_NetworkFiltering(t *testing.T) {
	filter := NewNodeFilter()

	nodes := []*models.Node{
		testutil.NewNodeBuilder().WithAddress(1, 100, 1).Build(),
		testutil.NewNodeBuilder().WithAddress(2, 5020, 1).Build(),
		testutil.NewNodeBuilder().WithAddress(2, 5020, 2).Build(),
		testutil.NewNodeBuilder().WithAddress(2, 5030, 1).Build(),
		testutil.NewNodeBuilder().WithAddress(3, 5020, 1).Build(), // Same net number, different zone
	}

	result := filter.FilterByTestLimit(nodes, "net:2:5020")

	if len(result) != 2 {
		t.Fatalf("Expected 2 nodes in 2:5020, got %d", len(result))
	}

	for _, node := range result {
		if node.Zone != 2 || node.Net != 5020 {
			t.Errorf("Got wrong node: %d:%d/%d", node.Zone, node.Net, node.Node)
		}
	}
}

func TestNodeFilter_ProtocolFiltering(t *testing.T) {
	filter := NewNodeFilter()

	nodes := []*models.Node{
		testutil.NewNodeBuilder().WithProtocols("IBN").Build(),
		testutil.NewNodeBuilder().WithProtocols("IFC").Build(),
		testutil.NewNodeBuilder().WithProtocols("IBN", "IFC").Build(),
		testutil.NewNodeBuilder().WithProtocols("ITN").Build(),
		testutil.NewNodeBuilder().WithProtocols().Build(), // No protocols
	}

	result := filter.FilterByTestLimit(nodes, "protocol:IBN")

	if len(result) != 2 {
		t.Fatalf("Expected 2 nodes with IBN, got %d", len(result))
	}

	for _, node := range result {
		if !node.HasProtocol("IBN") {
			t.Error("Got node without IBN protocol")
		}
	}
}

func TestNodeFilter_OnlineOnly(t *testing.T) {
	filter := NewNodeFilter()

	nodes := []*models.Node{
		func() *models.Node {
			n := testutil.NewNodeBuilder().WithProtocols("IBN").Build()
			n.HasInet = true
			return n
		}(),
		func() *models.Node {
			n := testutil.NewNodeBuilder().WithProtocols("IBN").Build()
			n.HasInet = true
			return n
		}(),
		func() *models.Node {
			n := testutil.NewNodeBuilder().WithProtocols().Build()
			n.HasInet = false
			return n
		}(),
	}

	result := filter.FilterByTestLimit(nodes, "online")

	if len(result) != 2 {
		t.Fatalf("Expected 2 online nodes, got %d", len(result))
	}

	for _, node := range result {
		if !node.IsOnline() {
			t.Error("Got offline node when filtering for online")
		}
	}
}

func TestNodeFilter_HubFiltering(t *testing.T) {
	filter := NewNodeFilter()

	nodes := []*models.Node{
		testutil.NewNodeBuilder().WithAddress(1, 1, 0).Build(), // Hub (node 0)
		testutil.NewNodeBuilder().WithAddress(1, 1, 1).Build(), // Regular node
		testutil.NewNodeBuilder().WithAddress(1, 2, 0).Build(), // Another hub
		testutil.NewNodeBuilder().WithAddress(1, 2, 100).Build(),
	}

	result := filter.FilterByTestLimit(nodes, "hubs")

	if len(result) != 2 {
		t.Fatalf("Expected 2 hubs, got %d", len(result))
	}

	for _, node := range result {
		if node.Node != 0 {
			t.Errorf("Got non-hub node: %d", node.Node)
		}
	}
}

func TestNodeFilter_HostFiltering(t *testing.T) {
	filter := NewNodeFilter()

	nodes := []*models.Node{
		testutil.NewNodeBuilder().WithFlags("HOST").Build(),
		testutil.NewNodeBuilder().WithFlags("Host").Build(),
		testutil.NewNodeBuilder().WithFlags("CM").Build(),
		testutil.NewNodeBuilder().WithFlags().Build(),
	}

	result := filter.FilterByTestLimit(nodes, "hosts")

	if len(result) != 2 {
		t.Fatalf("Expected 2 hosts, got %d", len(result))
	}

	for _, node := range result {
		if !node.IsHost() {
			t.Error("Got non-host node when filtering for hosts")
		}
	}
}

func TestNodeFilter_InvalidLimit(t *testing.T) {
	filter := NewNodeFilter()

	nodes := []*models.Node{
		testutil.NewNodeBuilder().Build(),
		testutil.NewNodeBuilder().Build(),
	}

	// Invalid limits should return all nodes
	tests := []string{
		"invalid",
		"xyz",
		"",
		"all",
	}

	for _, limit := range tests {
		t.Run(limit, func(t *testing.T) {
			result := filter.FilterByTestLimit(nodes, limit)
			if len(result) != len(nodes) {
				t.Errorf("Invalid limit '%s' should return all nodes", limit)
			}
		})
	}
}

func TestNodeFilter_EmptyInput(t *testing.T) {
	filter := NewNodeFilter()

	var nodes []*models.Node

	result := filter.FilterByTestLimit(nodes, "10")

	if len(result) != 0 {
		t.Errorf("Empty input should return empty result, got %d nodes", len(result))
	}
}

func TestNodeFilter_RandomSelection_Deterministic(t *testing.T) {
	// Random selection should be consistent for testing
	filter := NewNodeFilter()

	var nodes []*models.Node
	for i := 0; i < 100; i++ {
		nodes = append(nodes, testutil.NewNodeBuilder().
			WithAddress(1, 1, i+1).
			Build())
	}

	// Select 10 nodes multiple times
	result1 := filter.FilterByTestLimit(nodes, "10")
	result2 := filter.FilterByTestLimit(nodes, "10")

	if len(result1) != 10 || len(result2) != 10 {
		t.Error("Should select exactly 10 nodes")
	}

	// Results might differ due to randomization, but both should be valid subsets
	seen := make(map[int]bool)
	for _, node := range result1 {
		seen[node.Node] = true
	}

	if len(seen) != 10 {
		t.Error("Selected nodes should be unique")
	}
}