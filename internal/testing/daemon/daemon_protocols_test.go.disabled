package daemon

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/nodelistdb/internal/testing/daemon/mocks"
	"github.com/nodelistdb/internal/testing/protocols"
)

func TestBinkP_DualStack_TriesBoth(t *testing.T) {
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			// Simulate IPv6 failure, IPv4 success
			if addr == "2001:db8::1" {
				return protocols.TestResult{
					Success:      false,
					Error:        errors.New("connection refused"),
					ResponseTime: 100 * time.Millisecond,
				}
			}
			if addr == "192.168.1.1" {
				return protocols.TestResult{
					Success:      true,
					ResponseTime: 200 * time.Millisecond,
				}
			}
			return protocols.TestResult{
				Success: false,
				Error:   errors.New("unexpected address"),
			}
		},
	}

	daemon := &Daemon{
		binkpTester: mockTester,
	}

	ctx := context.Background()
	result := daemon.TestBinkP(ctx, "bbs.example.com", 24554, []string{"2001:db8::1", "192.168.1.1"})

	if !result.Success {
		t.Error("Expected success when IPv4 succeeds after IPv6 fails")
	}

	if result.ResponseTime != 200*time.Millisecond {
		t.Errorf("Expected response time from successful attempt, got %v", result.ResponseTime)
	}

	if result.TestedAddress != "192.168.1.1" {
		t.Errorf("Expected tested address to be IPv4, got %s", result.TestedAddress)
	}
}

func TestBinkP_IPv6First_ThenIPv4(t *testing.T) {
	callOrder := []string{}
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			callOrder = append(callOrder, addr)
			if addr == "2001:db8::1" {
				return protocols.TestResult{
					Success:      false,
					Error:        errors.New("timeout"),
					ResponseTime: 500 * time.Millisecond,
				}
			}
			if addr == "192.168.1.1" {
				return protocols.TestResult{
					Success:      true,
					ResponseTime: 100 * time.Millisecond,
				}
			}
			return protocols.TestResult{
				Success: false,
				Error:   errors.New("unexpected address"),
			}
		},
	}

	daemon := &Daemon{
		binkpTester: mockTester,
	}

	ctx := context.Background()
	// IPv6 should be tried first when both are available
	result := daemon.TestBinkP(ctx, "bbs.example.com", 24554, []string{"2001:db8::1", "192.168.1.1"})

	if !result.Success {
		t.Error("Expected success from IPv4 after IPv6 fails")
	}

	// Verify IPv6 was tried first
	if len(callOrder) < 1 || callOrder[0] != "2001:db8::1" {
		t.Errorf("Expected IPv6 to be tried first, got order: %v", callOrder)
	}
}

func TestBinkP_MultipleIPs_StopsOnSuccess(t *testing.T) {
	callCount := 0
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			callCount++
			if addr == "2001:db8::1" {
				// First address succeeds
				return protocols.TestResult{
					Success:      true,
					ResponseTime: 50 * time.Millisecond,
				}
			}
			// Should not reach these
			return protocols.TestResult{
				Success: false,
				Error:   errors.New("should not be called"),
			}
		},
	}

	daemon := &Daemon{
		binkpTester: mockTester,
	}

	ctx := context.Background()
	result := daemon.TestBinkP(ctx, "bbs.example.com", 24554, []string{"2001:db8::1", "192.168.1.1", "192.168.1.2"})

	if !result.Success {
		t.Error("Expected success from first address")
	}

	if callCount != 1 {
		t.Errorf("Expected only 1 call (stops on success), got %d", callCount)
	}

	if result.TestedAddress != "2001:db8::1" {
		t.Errorf("Expected tested address to be first successful, got %s", result.TestedAddress)
	}
}

func TestIfcico_DualStack_Behavior(t *testing.T) {
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			// Ifcico on port 60179
			if port != 60179 {
				return protocols.TestResult{
					Success: false,
					Error:   errors.New("wrong port"),
				}
			}
			if addr == "2001:db8::1" {
				return protocols.TestResult{
					Success:      false,
					Error:        errors.New("connection refused"),
					ResponseTime: 100 * time.Millisecond,
				}
			}
			if addr == "192.168.1.1" {
				return protocols.TestResult{
					Success:      true,
					ResponseTime: 150 * time.Millisecond,
				}
			}
			return protocols.TestResult{
				Success: false,
				Error:   errors.New("unexpected address"),
			}
		},
	}

	daemon := &Daemon{
		ifcicoTester: mockTester,
	}

	ctx := context.Background()
	result := daemon.TestIfcico(ctx, "bbs.example.com", 60179, []string{"2001:db8::1", "192.168.1.1"})

	if !result.Success {
		t.Error("Expected success when IPv4 succeeds")
	}

	if result.ResponseTime != 150*time.Millisecond {
		t.Errorf("Expected response time from successful attempt, got %v", result.ResponseTime)
	}
}

func TestTelnet_PortConfiguration(t *testing.T) {
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			// Telnet typically on port 23 or 60177
			if port == 60177 {
				return protocols.TestResult{
					Success:      true,
					ResponseTime: 80 * time.Millisecond,
				}
			}
			return protocols.TestResult{
				Success: false,
				Error:   errors.New("wrong port"),
			}
		},
	}

	daemon := &Daemon{
		telnetTester: mockTester,
	}

	ctx := context.Background()
	result := daemon.TestTelnet(ctx, "bbs.example.com", 60177, []string{"192.168.1.1"})

	if !result.Success {
		t.Error("Expected success on correct telnet port")
	}

	if result.ResponseTime != 80*time.Millisecond {
		t.Errorf("Expected response time 80ms, got %v", result.ResponseTime)
	}
}

func TestProtocol_Timeout_Handling(t *testing.T) {
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			// Simulate timeout by checking context
			select {
			case <-ctx.Done():
				return protocols.TestResult{
					Success:      false,
					Error:        ctx.Err(),
					ResponseTime: 0,
				}
			case <-time.After(10 * time.Second):
				// This should not be reached
				return protocols.TestResult{
					Success:      true,
					ResponseTime: 10 * time.Second,
				}
			}
		},
	}

	daemon := &Daemon{
		binkpTester: mockTester,
	}

	// Create context with short timeout
	ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
	defer cancel()

	result := daemon.TestBinkP(ctx, "slow.example.com", 24554, []string{"192.168.1.1"})

	if result.Success {
		t.Error("Expected failure due to timeout")
	}

	if result.Error == nil {
		t.Error("Expected timeout error")
	}
}

func TestProtocol_NoAddresses_HandlesGracefully(t *testing.T) {
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			// Should not be called
			return protocols.TestResult{
				Success: false,
				Error:   errors.New("should not be called"),
			}
		},
	}

	daemon := &Daemon{
		binkpTester: mockTester,
	}

	ctx := context.Background()
	result := daemon.TestBinkP(ctx, "bbs.example.com", 24554, []string{})

	if result.Success {
		t.Error("Expected failure when no addresses provided")
	}

	if result.Error == nil || result.Error.Error() != "no addresses to test" {
		t.Errorf("Expected 'no addresses to test' error, got %v", result.Error)
	}
}

func TestProtocol_AllAddressesFail(t *testing.T) {
	attemptCount := 0
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			attemptCount++
			return protocols.TestResult{
				Success:      false,
				Error:        errors.New("connection refused"),
				ResponseTime: 100 * time.Millisecond,
			}
		},
	}

	daemon := &Daemon{
		binkpTester: mockTester,
	}

	ctx := context.Background()
	result := daemon.TestBinkP(ctx, "bbs.example.com", 24554, []string{"192.168.1.1", "192.168.1.2", "192.168.1.3"})

	if result.Success {
		t.Error("Expected failure when all addresses fail")
	}

	if attemptCount != 3 {
		t.Errorf("Expected 3 attempts, got %d", attemptCount)
	}

	if result.Error == nil {
		t.Error("Expected error from last failed attempt")
	}
}

func TestProtocol_IPv6Only_Success(t *testing.T) {
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			if addr == "2001:db8::1" {
				return protocols.TestResult{
					Success:      true,
					ResponseTime: 75 * time.Millisecond,
				}
			}
			return protocols.TestResult{
				Success: false,
				Error:   errors.New("unexpected address"),
			}
		},
	}

	daemon := &Daemon{
		binkpTester: mockTester,
	}

	ctx := context.Background()
	result := daemon.TestBinkP(ctx, "ipv6.example.com", 24554, []string{"2001:db8::1"})

	if !result.Success {
		t.Error("Expected success with IPv6-only address")
	}

	if result.TestedAddress != "2001:db8::1" {
		t.Errorf("Expected tested address to be IPv6, got %s", result.TestedAddress)
	}
}

func TestProtocol_IPv4Only_Success(t *testing.T) {
	mockTester := &mocks.MockProtocolTester{
		TestFunc: func(ctx context.Context, host string, port int, addr string) protocols.TestResult {
			if addr == "192.168.1.1" {
				return protocols.TestResult{
					Success:      true,
					ResponseTime: 90 * time.Millisecond,
				}
			}
			return protocols.TestResult{
				Success: false,
				Error:   errors.New("unexpected address"),
			}
		},
	}

	daemon := &Daemon{
		binkpTester: mockTester,
	}

	ctx := context.Background()
	result := daemon.TestBinkP(ctx, "ipv4.example.com", 24554, []string{"192.168.1.1"})

	if !result.Success {
		t.Error("Expected success with IPv4-only address")
	}

	if result.TestedAddress != "192.168.1.1" {
		t.Errorf("Expected tested address to be IPv4, got %s", result.TestedAddress)
	}
}